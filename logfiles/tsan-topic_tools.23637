==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M448 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M709 (0x7b50000200b0) => M708 (0x7b540000ffc0) => M709

  Mutex M708 acquired here while holding mutex M709 in thread T1:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 ros::TransportTCP::read(unsigned char*, unsigned int) <null> (libroscpp.so+0x113801)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M709 acquired here while holding mutex M708 in thread T1:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

  Thread T1 (tid=23668, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M747 (0x7b50000200b0) => M746 (0x7b540000ffc0) => M747

  Mutex M746 acquired here while holding mutex M747 in thread T1:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 ros::TransportTCP::read(unsigned char*, unsigned int) <null> (libroscpp.so+0x113801)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M747 acquired here while holding mutex M746 in thread T1:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

  Thread T1 (tid=23668, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M424 (0x7fb8ed7c8720) => M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M448 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: data race (pid=23637)
  Write of size 8 at 0x7b1000000e50 by main thread (mutexes: write M420, write M451, write M632):
    #0 operator delete(void*) <null> (libtsan.so.0+0x741fd)
    #1 boost::detail::sp_counted_impl_pd<rosgraph_msgs::Log_<std::allocator<void> >*, boost::detail::sp_ms_deleter<rosgraph_msgs::Log_<std::allocator<void> > > >::dispose() <null> (libroscpp.so+0x12fc5d)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Previous read of size 1 at 0x7b1000000e56 by thread T3 (mutexes: write M592):
    #0 memcpy <null> (libtsan.so.0+0x32515)
    #1 ros::SerializedMessage ros::serialization::serializeMessage<rosgraph_msgs::Log_<std::allocator<void> > >(rosgraph_msgs::Log_<std::allocator<void> > const&) <null> (libroscpp.so+0x13044e)

  Mutex M420 (0x7fb8ed7c88e0) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 boost::mutex::mutex() <null> (libroscpp.so+0x12149e)

  Mutex M451 (0x7fb8ef022148) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)

  Mutex M632 (0x7fb8e713a0a8) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M592 (0x7b4400000420) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 ros::TopicManager::TopicManager() <null> (libroscpp.so+0xd1028)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Thread T3 (tid=23678, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: data race (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x741fd) in operator delete(void*)
==================
==================
WARNING: ThreadSanitizer: data race (pid=23637)
  Write of size 8 at 0x7b1000000d40 by main thread (mutexes: write M420, write M451, write M632):
    #0 operator delete(void*) <null> (libtsan.so.0+0x741fd)
    #1 boost::detail::sp_counted_impl_pd<rosgraph_msgs::Log_<std::allocator<void> >*, boost::detail::sp_ms_deleter<rosgraph_msgs::Log_<std::allocator<void> > > >::dispose() <null> (libroscpp.so+0x12fc75)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Previous read of size 8 at 0x7b1000000d40 by thread T3 (mutexes: write M592):
    #0 memcpy <null> (libtsan.so.0+0x32515)
    #1 ros::SerializedMessage ros::serialization::serializeMessage<rosgraph_msgs::Log_<std::allocator<void> > >(rosgraph_msgs::Log_<std::allocator<void> > const&) <null> (libroscpp.so+0x1303c3)

  Mutex M420 (0x7fb8ed7c88e0) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 boost::mutex::mutex() <null> (libroscpp.so+0x12149e)

  Mutex M451 (0x7fb8ef022148) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)

  Mutex M632 (0x7fb8e713a0a8) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M592 (0x7b4400000420) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 ros::TopicManager::TopicManager() <null> (libroscpp.so+0xd1028)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Thread T3 (tid=23678, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: data race (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x741fd) in operator delete(void*)
==================
==================
WARNING: ThreadSanitizer: data race (pid=23637)
  Write of size 8 at 0x7b1000000d00 by main thread (mutexes: write M420, write M451, write M632):
    #0 operator delete(void*) <null> (libtsan.so.0+0x741fd)
    #1 boost::detail::sp_counted_impl_pd<rosgraph_msgs::Log_<std::allocator<void> >*, boost::detail::sp_ms_deleter<rosgraph_msgs::Log_<std::allocator<void> > > >::dispose() <null> (libroscpp.so+0x12fc8d)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Previous read of size 8 at 0x7b1000000d00 by thread T3 (mutexes: write M592):
    #0 memcpy <null> (libtsan.so.0+0x32515)
    #1 ros::SerializedMessage ros::serialization::serializeMessage<rosgraph_msgs::Log_<std::allocator<void> > >(rosgraph_msgs::Log_<std::allocator<void> > const&) <null> (libroscpp.so+0x13037a)

  Mutex M420 (0x7fb8ed7c88e0) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 boost::mutex::mutex() <null> (libroscpp.so+0x12149e)

  Mutex M451 (0x7fb8ef022148) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)

  Mutex M632 (0x7fb8e713a0a8) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M592 (0x7b4400000420) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 ros::TopicManager::TopicManager() <null> (libroscpp.so+0xd1028)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Thread T3 (tid=23678, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: data race (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x741fd) in operator delete(void*)
==================
==================
WARNING: ThreadSanitizer: data race (pid=23637)
  Write of size 8 at 0x7b0800001720 by main thread (mutexes: write M420, write M451, write M632):
    #0 operator delete(void*) <null> (libtsan.so.0+0x741fd)
    #1 boost::detail::sp_counted_impl_pd<rosgraph_msgs::Log_<std::allocator<void> >*, boost::detail::sp_ms_deleter<rosgraph_msgs::Log_<std::allocator<void> > > >::dispose() <null> (libroscpp.so+0x12fca2)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Previous read of size 8 at 0x7b0800001720 by thread T3 (mutexes: write M592):
    #0 memcpy <null> (libtsan.so.0+0x32515)
    #1 ros::SerializedMessage ros::serialization::serializeMessage<rosgraph_msgs::Log_<std::allocator<void> > >(rosgraph_msgs::Log_<std::allocator<void> > const&) <null> (libroscpp.so+0x130335)

  Mutex M420 (0x7fb8ed7c88e0) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 boost::mutex::mutex() <null> (libroscpp.so+0x12149e)

  Mutex M451 (0x7fb8ef022148) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)

  Mutex M632 (0x7fb8e713a0a8) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M592 (0x7b4400000420) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 ros::TopicManager::TopicManager() <null> (libroscpp.so+0xd1028)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Thread T3 (tid=23678, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: data race (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x741fd) in operator delete(void*)
==================
==================
WARNING: ThreadSanitizer: data race (pid=23637)
  Write of size 8 at 0x7b4000000168 by main thread (mutexes: write M420, write M451, write M632):
    #0 operator delete(void*) <null> (libtsan.so.0+0x741fd)
    #1 ros::ROSOutAppender::log(ros::console::levels::Level, char const*, char const*, char const*, int) <null> (libroscpp.so+0x12f7f9)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Previous read of size 8 at 0x7b4000000168 by thread T3 (mutexes: write M592):
    #0 memcpy <null> (libtsan.so.0+0x32515)
    #1 ros::SerializedMessage ros::serialization::serializeMessage<rosgraph_msgs::Log_<std::allocator<void> > >(rosgraph_msgs::Log_<std::allocator<void> > const&) <null> (libroscpp.so+0x1302f2)

  Mutex M420 (0x7fb8ed7c88e0) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 boost::mutex::mutex() <null> (libroscpp.so+0x12149e)

  Mutex M451 (0x7fb8ef022148) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)

  Mutex M632 (0x7fb8e713a0a8) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 apr_thread_mutex_create <null> (libapr-1.so.0+0x1be0b)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M592 (0x7b4400000420) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 ros::TopicManager::TopicManager() <null> (libroscpp.so+0xd1028)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Thread T3 (tid=23678, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: data race (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x741fd) in operator delete(void*)
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M746 (0x7b540000ffc0) => M748 (0x7b5000020118) => M746

  Mutex M748 acquired here while holding mutex M746 in thread T1:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M746 acquired here while holding mutex M748 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 ros::TransportTCP::disableWrite() <null> (libroscpp.so+0x112fc7)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

  Thread T1 (tid=23668, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: data race (pid=23637)
  Write of size 8 at 0x7b0800003768 by main thread (mutexes: write M666, write M857):
    #0 operator delete(void*) <null> (libtsan.so.0+0x741fd)
    #1 boost::detail::sp_counted_impl_pd<unsigned char*, boost::checked_array_deleter<unsigned char> >::~sp_counted_impl_pd() /usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp:146 (mux+0x78f4c)
    #2 ros::MessageDeserializer::deserialize() <null> (libroscpp.so+0x14d705)
    #3 __libc_start_main <null> (libc.so.6+0x21b96)

  Previous atomic write of size 4 at 0x7b0800003768 by thread T1 (mutexes: write M808, write M809):
    #0 __tsan_atomic32_fetch_sub <null> (libtsan.so.0+0x68aed)
    #1 std::__atomic_base<int>::fetch_sub(int, std::memory_order) /usr/include/c++/7/bits/atomic_base.h:524 (mux+0x56da8)
    #2 boost::detail::atomic_decrement(std::atomic<int>*) /usr/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp:35 (mux+0x56da8)
    #3 boost::detail::sp_counted_base::release() /usr/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp:108 (mux+0x56f58)
    #4 ros::Connection::readTransport() <null> (libroscpp.so+0x9f87d)

  Mutex M666 (0x7b4400000c20) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 ros::SubscriptionQueue::SubscriptionQueue(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int, bool) <null> (libroscpp.so+0x146fa8)
    #2 main /catkin/buildtmp/topic_tools/src/topic_tools/src/mux.cpp:318 (mux+0x55327)

  Mutex M857 (0x7b2c00010038) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 ros::MessageDeserializer::MessageDeserializer(boost::shared_ptr<ros::SubscriptionCallbackHelper> const&, ros::SerializedMessage const&, boost::shared_ptr<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > const&) <null> (libroscpp.so+0x14d289)

  Mutex M808 (0x7b5400020140) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 ros::TransportTCP::TransportTCP(ros::PollSet*, int) <null> (libroscpp.so+0x112d4f)

  Mutex M809 (0x7b50000306b0) created at:
    #0 pthread_mutex_init <null> (libtsan.so.0+0x2c5bd)
    #1 boost::recursive_mutex::recursive_mutex() <null> (libroscpp.so+0xa47ed)

  Thread T1 (tid=23668, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: data race (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x741fd) in operator delete(void*)
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M632 (0x7fb8e713a0a8) => M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M632

  Mutex M448 acquired here while holding mutex M632 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

  Mutex M632 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M493 (0x7fb8edb65540) => M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M493

  Mutex M448 acquired here while holding mutex M493 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

  Mutex M493 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 ros::param::getImpl(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, XmlRpc::XmlRpcValue&, bool) <null> (libroscpp.so+0xab0a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M594 (0x7b44000004a8) => M583 (0x7b48000002b0) => M594

  Mutex M583 acquired here while holding mutex M594 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 ros::PollManager::addPollThreadListener(boost::function<void ()> const&) <null> (libroscpp.so+0xdaab2)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M594 acquired here while holding mutex M583 in thread T1:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)

  Thread T1 (tid=23668, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M591 (0x7b44000003e0) => M592 (0x7b4400000420) => M591

  Mutex M592 acquired here while holding mutex M591 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)
    #2 main /catkin/buildtmp/topic_tools/src/topic_tools/src/mux.cpp:318 (mux+0x55327)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M591 acquired here while holding mutex M592 in thread T1:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)

  Thread T1 (tid=23668, running) created by main thread at:
    #0 pthread_create <null> (libtsan.so.0+0x2bcfe)
    #1 boost::thread::start_thread_noexcept() <null> (libboost_thread.so.1.65.1+0x10b09)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=23637)
  Cycle in lock order graph: M448 (0x7fb8ef0220a8) => M451 (0x7fb8ef022148) => M424 (0x7fb8ed7c8720) => M448

  Mutex M451 acquired here while holding mutex M448 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M424 acquired here while holding mutex M451 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::mutex>::lock() <null> (libroscpp.so+0xa52a7)
    #2 boost::detail::function::function_invoker2<bool (*)(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&), bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::invoke(boost::detail::function::function_buffer&, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) /usr/include/boost/function/function_template.hpp:101 (mux+0x6a8d9)
    #3 boost::function2<bool, topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&>::operator()(topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&) const /usr/include/boost/function/function_template.hpp:760 (mux+0x7edc3)
    #4 ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >::call(boost::function<bool (topic_tools::MuxSelectRequest_<std::allocator<void> >&, topic_tools::MuxSelectResponse_<std::allocator<void> >&)> const&, ros::ServiceSpecCallParams<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > >&) /opt/ros/melodic/include/ros/service_callback_helper.h:125 (mux+0x7d66e)
    #5 ros::ServiceCallbackHelperT<ros::ServiceSpec<topic_tools::MuxSelectRequest_<std::allocator<void> >, topic_tools::MuxSelectResponse_<std::allocator<void> > > >::call(ros::ServiceCallbackHelperCallParams&) /opt/ros/melodic/include/ros/service_callback_helper.h:182 (mux+0x7adac)
    #6 ros::ServiceCallback::call() <null> (libroscpp.so+0x9aa03)
    #7 __libc_start_main <null> (libc.so.6+0x21b96)

  Mutex M448 acquired here while holding mutex M424 in main thread:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 log4cxx::helpers::synchronized::synchronized(log4cxx::helpers::Mutex const&) <null> (liblog4cxx.so.10+0x14acdb)
    #2 __libc_start_main <null> (libc.so.6+0x21b96)

SUMMARY: ThreadSanitizer: lock-order-inversion (potential deadlock) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: use of an invalid mutex (e.g. uninitialized or destroyed) (pid=23637)
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

  Mutex M3384 (0x7b4400000420) created at:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

SUMMARY: ThreadSanitizer: use of an invalid mutex (e.g. uninitialized or destroyed) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: heap-use-after-free (pid=23637)
  Atomic read of size 1 at 0x7b4400000420 by main thread:
    #0 pthread_mutex_unlock <null> (libtsan.so.0+0x3fc59)
    #1 ros::TopicManager::unadvertise(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::shared_ptr<ros::SubscriberCallbacks> const&) <null> (libroscpp.so+0xd330e)

  Previous write of size 8 at 0x7b4400000420 by main thread:
    #0 operator delete(void*) <null> (libtsan.so.0+0x741fd)
    #1 boost::detail::sp_counted_base::destroy() /usr/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp:89 (mux+0x56ef2)
    #2 boost::detail::sp_counted_base::weak_release() /usr/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp:124 (mux+0x57019)
    #3 boost::detail::sp_counted_base::release() /usr/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp:111 (mux+0x56f99)
    #4 <null> <null> (libtsan.so.0+0x28193)

SUMMARY: ThreadSanitizer: heap-use-after-free (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3fc59) in pthread_mutex_unlock
==================
==================
WARNING: ThreadSanitizer: unlock of an unlocked mutex (or by a wrong thread) (pid=23637)
    #0 pthread_mutex_unlock <null> (libtsan.so.0+0x3fc59)
    #1 ros::TopicManager::unadvertise(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::shared_ptr<ros::SubscriberCallbacks> const&) <null> (libroscpp.so+0xd330e)

  Mutex M3384 (0x7b4400000420) created at:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

SUMMARY: ThreadSanitizer: unlock of an unlocked mutex (or by a wrong thread) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3fc59) in pthread_mutex_unlock
==================
==================
WARNING: ThreadSanitizer: use of an invalid mutex (e.g. uninitialized or destroyed) (pid=23637)
    #0 pthread_mutex_unlock <null> (libtsan.so.0+0x3fc59)
    #1 ros::TopicManager::unadvertise(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::shared_ptr<ros::SubscriberCallbacks> const&) <null> (libroscpp.so+0xd330e)

  Mutex M3384 (0x7b4400000420) created at:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

SUMMARY: ThreadSanitizer: use of an invalid mutex (e.g. uninitialized or destroyed) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3fc59) in pthread_mutex_unlock
==================
==================
WARNING: ThreadSanitizer: use of an invalid mutex (e.g. uninitialized or destroyed) (pid=23637)
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

  Mutex M3384 (0x7b4400000420) created at:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

SUMMARY: ThreadSanitizer: use of an invalid mutex (e.g. uninitialized or destroyed) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3faeb) in __interceptor_pthread_mutex_lock
==================
==================
WARNING: ThreadSanitizer: use of an invalid mutex (e.g. uninitialized or destroyed) (pid=23637)
    #0 pthread_mutex_unlock <null> (libtsan.so.0+0x3fc59)
    #1 ros::TopicManager::unadvertise(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::shared_ptr<ros::SubscriberCallbacks> const&) <null> (libroscpp.so+0xd330e)

  Mutex M3384 (0x7b4400000420) created at:
    #0 pthread_mutex_lock <null> (libtsan.so.0+0x3faeb)
    #1 boost::unique_lock<boost::recursive_mutex>::lock() <null> (libroscpp.so+0xa4ddf)

SUMMARY: ThreadSanitizer: use of an invalid mutex (e.g. uninitialized or destroyed) (/usr/lib/x86_64-linux-gnu/libtsan.so.0+0x3fc59) in pthread_mutex_unlock
==================
ThreadSanitizer: reported 31 warnings
